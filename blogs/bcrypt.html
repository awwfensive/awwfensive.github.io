<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Breaking Authentication: Bcrypt Truncation & Email Normalization — awwfensive</title>
    <link rel="icon" type="image/png" sizes="32x32" href="../favicon.png">
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: monospace;
            background: #fdfdfd;
            color: #222;
            font-size: 18px;
            line-height: 1.7;
        }
        .container {
            max-width: 720px;
            margin: auto;
        }
        header {
            margin-bottom: 2.5rem;
            border-bottom: 2px solid #4caf50;
            padding-bottom: 1rem;
        }
        h1 {
            margin: 0 0 10px;
            font-size: 2.5rem;
            color: #000;
            line-height: 1.2;
        }
        h1::before {
            content: "$ ";
            color: #4caf50;
        }
        .post-meta {
            font-size: 1rem;
            color: #666;
            margin-bottom: 5px;
        }
        .post-tags {
            margin-top: 10px;
        }
        .tag {
            display: inline-block;
            background: #f0f0f0;
            color: #555;
            padding: 3px 10px;
            margin-right: 8px;
            margin-bottom: 5px;
            border-radius: 3px;
            font-size: 0.9rem;
        }
        .tag::before {
            content: "#";
            color: #4caf50;
            margin-right: 2px;
        }
        article {
            margin-bottom: 3rem;
        }
        article h2 {
            font-size: 1.8rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            color: #000;
        }
        article h3 {
            font-size: 1.4rem;
            margin-top: 1.5rem;
            margin-bottom: 0.8rem;
            color: #111;
        }
        article h4 {
            font-size: 1.2rem;
            margin-top: 1.2rem;
            margin-bottom: 0.6rem;
            color: #222;
        }
        article p {
            margin-bottom: 1.2rem;
        }
        article a {
            color: #0066cc;
            text-decoration: none;
        }
        article a:hover {
            text-decoration: underline;
        }
        article code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.95em;
            color: #d63384;
        }
        article pre {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            line-height: 1.5;
            margin: 1.5rem 0;
        }
        article pre code {
            background: none;
            color: inherit;
            padding: 0;
        }
        article blockquote {
            margin: 1.5rem 0;
            padding-left: 20px;
            border-left: 4px solid #4caf50;
            color: #555;
            font-style: italic;
        }
        article ul, article ol {
            margin-bottom: 1.2rem;
            padding-left: 2rem;
        }
        article li {
            margin-bottom: 0.5rem;
        }
        article img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 2rem auto;
            border-radius: 5px;
        }
        .note {
            background: #fffbea;
            border-left: 4px solid #ffa500;
            padding: 15px;
            margin: 1.5rem 0;
            border-radius: 3px;
        }
        .note strong {
            color: #ff8c00;
        }
        .danger {
            background: #ffe5e5;
            border-left: 4px solid #dc3545;
            padding: 15px;
            margin: 1.5rem 0;
            border-radius: 3px;
        }
        .danger strong {
            color: #dc3545;
        }
        .info {
            background: #e7f3ff;
            border-left: 4px solid #0066cc;
            padding: 15px;
            margin: 1.5rem 0;
            border-radius: 3px;
        }
        .info strong {
            color: #0066cc;
        }
        .section-divider {
            border: none;
            border-top: 2px dashed #ccc;
            margin: 2rem 0;
        }
        .attack-chain {
            background: #f8f9fa;
            border: 2px solid #4caf50;
            padding: 20px;
            margin: 1.5rem 0;
            border-radius: 5px;
        }
        .attack-chain h4 {
            margin-top: 0;
            color: #4caf50;
        }
        .attack-step {
            position: relative;
            padding-left: 35px;
            margin-bottom: 15px;
        }
        .attack-step::before {
            content: "→";
            position: absolute;
            left: 10px;
            color: #4caf50;
            font-size: 1.2rem;
            font-weight: bold;
        }
        footer {
            margin-top: 3rem;
            font-size: 1rem;
            color: #777;
            text-align: center;
        }
        footer a {
            color: #555;
            text-decoration: none;
        }
        footer a:hover {
            color: #0066cc;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Breaking Authentication: Bcrypt Truncation & Email Normalization</h1>
            <div class="post-meta">
                <span>October 21, 2025</span> · 
                <span>10 min read</span>
            </div>
            <div class="post-tags">
                <span class="tag">ImaginaryCTF2025</span>
                <span class="tag">passwordless</span>
                <span class="tag">authentication</span>
                <span class="tag">bcrypt</span>
                <span class="tag">nodejs</span>
            </div>
        </header>

        <article>
            <h2>Introduction</h2>
            <p>
                During ImaginaryCTF 2025, I tackled a fascinating web challenge called "passwordless" that showcased how multiple subtle implementation flaws can combine to create a critical authentication bypass. The challenge presented a Node.js authentication system where users register with their email and receive a randomly generated temporary password—except the password delivery mechanism was never implemented.
            </p>

            <p>
                What made this challenge particularly interesting is that every security component appeared properly implemented at first glance: bcrypt for password hashing, email normalization to prevent duplicates, input validation, and rate limiting. However, the devil was in the details. The interaction between bcrypt's 72-byte truncation limit, inconsistent email processing, and user-controlled password components created a perfect exploit chain allowing complete authentication bypass.
            </p>

            <div class="attack-chain">
                <h4>Attack Chain Overview</h4>
                <div class="attack-step">Identify password generation uses raw email + random hex</div>
                <div class="attack-step">Discover bcrypt truncates passwords at 72 bytes</div>
                <div class="attack-step">Find inconsistent email normalization between validation and password generation</div>
                <div class="attack-step">Craft 72-byte email that normalizes to &lt;64 chars</div>
                <div class="attack-step">Register account bypassing length validation</div>
                <div class="attack-step">Login using email as password (random portion ignored by bcrypt)</div>
            </div>

            <hr class="section-divider">

            <h2>The Application</h2>

            <p>
                The target was a straightforward Express.js application with user registration and login functionality. The system was designed to send users a temporary password via email upon registration, though this feature remained unimplemented at the time of discovery.
            </p>

            <div class="info">
                <strong>Key Features:</strong>
                <ul style="margin: 10px 0 0 20px;">
                    <li>Email-based registration with auto-generated temporary passwords</li>
                    <li>Bcrypt password hashing for secure storage</li>
                    <li>Email normalization to prevent duplicate accounts</li>
                    <li>Rate limiting on authentication endpoints</li>
                    <li>Session-based authentication after login</li>
                </ul>
            </div>

            <h3>Technology Stack</h3>
            <ul>
                <li><strong>Runtime:</strong> Node.js with Express.js framework</li>
                <li><strong>Database:</strong> SQLite3 with in-memory storage</li>
                <li><strong>Password Hashing:</strong> bcrypt (10 rounds)</li>
                <li><strong>Email Processing:</strong> normalize-email npm package</li>
                <li><strong>Session Management:</strong> express-session with MemoryStore</li>
            </ul>

            <hr class="section-divider">

            <h2>Source Code Analysis</h2>

            <p>
                Let's examine the vulnerable registration endpoint in detail. The code appears straightforward but contains subtle flaws that become apparent under scrutiny.
            </p>

            <h3>User Registration Endpoint</h3>

            <pre><code>app.post('/user', limiter, (req, res, next) => {
    if (!req.body) return res.redirect('/login')

    const nEmail = normalizeEmail(req.body.email)

    if (nEmail.length > 64) {
        req.session.error = 'Your email address is too long'
        return res.redirect('/login')
    }

    const initialPassword = req.body.email + crypto.randomBytes(16).toString('hex')
    bcrypt.hash(initialPassword, 10, function (err, hash) {
        if (err) return next(err)

        const query = "INSERT INTO users VALUES (?, ?)"
        db.run(query, [nEmail, hash], (err) => {
            if (err) {
                if (err.code === 'SQLITE_CONSTRAINT') {
                    req.session.error = 'This email address is already registered'
                    return res.redirect('/login')
                }
                return next(err)
            }

            // TODO: Send email with initial password

            req.session.message = 'An email has been sent with a temporary password for you to log in'
            res.redirect('/login')
        })
    })
})</code></pre>

            <hr class="section-divider">

            <h2>Vulnerability Analysis</h2>

            <h3>Vulnerability #1: Predictable Password Generation</h3>

            <p>
                The application generates temporary passwords using a combination of the user's email and random bytes:
            </p>

            <pre><code>const initialPassword = req.body.email + crypto.randomBytes(16).toString('hex')</code></pre>

            <p>
                This creates a password with the following structure:
            </p>

            <div class="info">
                <strong>Password Format:</strong><br>
                <code>[user_email_address] + [32_hexadecimal_characters]</code>
                <br><br>
                <strong>Example:</strong><br>
                <code>counter@strike.com</code> + <code>a3f9b7d1e84c6f2a5c3d7e98f0a123bc</code>
                <br>
                Result: <code>counter@strike.coma3f9b7d1e84c6f2a5c3d7e98f0a123bc</code>
            </div>

            <p>
                While the random component appears to provide security, this design has a critical flaw: it includes user-controlled data (the email address) as part of the password. Since users control the length of their email, they can influence what portion of the password bcrypt actually processes.
            </p>

            <h3>Vulnerability #2: Bcrypt's 72-Byte Truncation</h3>

            <p>
                Bcrypt has a well-documented limitation that's often overlooked: it only processes the first 72 bytes of input and silently discards everything beyond that point. This isn't a bug—it's a fundamental characteristic of bcrypt's design.
            </p>

            <div class="danger">
                <strong>Security Impact:</strong> If an attacker can create an email address that's exactly 72 bytes long, the random hexadecimal suffix will be completely ignored by bcrypt. This effectively makes the password equal to the email address itself, since bcrypt never sees the random portion.
            </div>

            <h4>How Bcrypt Processes Our Password</h4>

            <pre><code>// Password with short email (20 bytes)
Input:     "user@example.com" + "a3f9b7d1e84c6f2a5c3d7e98f0a123bc"
           [----------------] [------------------------------]
           20 bytes email     32 bytes random hex
Total:     52 bytes
Bcrypt:    Hashes all 52 bytes (random portion IS used)

// Password with 72-byte email (attack scenario)
Input:     "cs...[70 dots]...2@gmail.com" + "a3f9b7d1e84c6f2a5c3d7e98f0a123bc"
           [---------------------------] [------------------------------]
           72 bytes email                32 bytes random hex
Total:     104 bytes
Bcrypt:    Hashes only first 72 bytes (random portion IGNORED!)</code></pre>

            <p>
                In the attack scenario, bcrypt only sees the email portion. The 32 random characters are silently truncated, making the password predictable and equal to the email address.
            </p>

            <h3>Vulnerability #3: Inconsistent Email Processing</h3>

            <p>
                The critical vulnerability lies in how the application processes emails differently at different stages:
            </p>

            <pre><code>// Stage 1: Length validation
const nEmail = normalizeEmail(req.body.email)  // ← Uses normalized email
if (nEmail.length > 64) {
    // Reject if too long
}

// Stage 2: Password generation
const initialPassword = req.body.email + crypto.randomBytes(16).toString('hex')  // ← Uses raw email!</code></pre>

            <div class="danger">
                <strong>The Vulnerability:</strong> Length validation checks the normalized email, but password generation uses the raw email from the request body. This inconsistency creates a bypass opportunity.
            </div>

            <h4>Why This Matters</h4>

            <p>
                If we can craft an email that:
            </p>
            <ol>
                <li>Normalizes to ≤64 characters (passes validation)</li>
                <li>Is exactly 72 bytes in raw form (triggers bcrypt truncation)</li>
            </ol>

            <p>
                Then we can bypass both the length check AND make the password predictable!
            </p>

            <h3>Vulnerability #4: Email Normalization Behavior</h3>

            <p>
                The <code>normalize-email</code> library removes dots and plus signs from Gmail addresses as part of its normalization process. This is intended to prevent users from creating multiple accounts with variations of the same email.
            </p>

            <h4>Normalization Examples</h4>

            <pre><code>// Dot removal
Input:  "user.name@gmail.com"
Output: "username@gmail.com"

// Multiple dots
Input:  "u.s.e.r@gmail.com"
Output: "user@gmail.com"

// Plus addressing removal
Input:  "user+tag123@gmail.com"
Output: "user@gmail.com"

// Combined
Input:  "u.s.e.r+testing@gmail.com"
Output: "user@gmail.com"</code></pre>

            <div class="info">
                <strong>Attack Opportunity:</strong> We can use dots to artificially inflate the raw email length while keeping the normalized version short. For example, an email with 100 dots will normalize to a much shorter string, but the raw input remains long.
            </div>

            <hr class="section-divider">

            <h2>Exploitation Strategy</h2>

            <p>
                Now that we understand all the vulnerabilities, let's develop our attack strategy. We need to create an email that satisfies these precise constraints:
            </p>

            <div class="attack-chain">
                <h4>Attack Requirements</h4>
                <div class="attack-step">Raw email must be exactly 72 bytes</div>
                <div class="attack-step">Normalized email must be ≤64 characters</div>
                <div class="attack-step">Must be a valid email format</div>
                <div class="attack-step">Must work with Gmail normalization rules</div>
            </div>

            <h3>Constructing the Payload</h3>

            <p>
                The key insight is to use dots in a Gmail address. Let's work through the math:
            </p>

            <pre><code>// Base Gmail address
"cs2@gmail.com"  // 14 bytes when normalized

// We need 72 bytes total in raw form
// Domain portion: "@gmail.com" = 10 bytes
// Remaining space: 72 - 10 = 62 bytes for local part

// We already have "cs" and "2" = 3 characters
// Need: 62 - 3 = 59 more characters (use dots)

// Final payload structure:
"cs" + [59 dots] + "2@gmail.com"</code></pre>

            <h4>Payload Verification</h4>

            <pre><code>Raw Email:
cs.....................................................................................................................................................2@gmail.com
(72 bytes total)

Normalized Email:
cs2@gmail.com
(13 bytes - well under 64 limit!)

Password Construction:
initialPassword = "cs...[59 dots]...2@gmail.com" + "a3f9b7d1e84c6f2a5c3d7e98f0a123bc"
                  [-----------------------------]   [------------------------------]
                  72 bytes (all bcrypt sees)        32 bytes (ignored by bcrypt)

Effective Password:
cs.....................................................................................................................................................2@gmail.com
(Just the email - random portion never hashed!)</code></pre>

            <hr class="section-divider">

            <h2>Step-by-Step Exploitation</h2>

            <h3>Step 1: Crafting the Malicious Email</h3>

            <p>
                First, let's create our precisely crafted email address with exactly 72 bytes:
            </p>

            <pre><code>cs.....................................................................................................................................................2@gmail.com</code></pre>

            <div class="note">
                <strong>Important:</strong> Count carefully! The email must be exactly 72 bytes. Too few and the random portion will be partially included; too many and the validation check might fail depending on how dots are counted.
            </div>

            <h3>Step 2: Registration</h3>

            <p>
                Navigate to the registration page and enter the crafted email in the registration form. When submitting:
            </p>

            <ol>
                <li>The application receives the raw 72-byte email</li>
                <li>It normalizes the email to <code>cs2@gmail.com</code> (13 bytes)</li>
                <li>The length check passes (13 ≤ 64)</li>
                <li>Password is generated: 72-byte email + 32 hex chars = 104 bytes</li>
                <li>Bcrypt hashes only first 72 bytes (just the email)</li>
                <li>Database stores the normalized email with the truncated hash</li>
            </ol>

            <div class="info">
                <strong>Registration Success:</strong> The application accepts our registration and displays a message about sending an email with temporary password. Of course, no email is actually sent since that feature isn't implemented.
            </div>

            <h3>Step 3: Authentication Bypass</h3>

            <p>
                Now comes the moment of truth. Navigate to the login page and enter:
            </p>

            <pre><code>Email:    cs.....................................................................................................................................................2@gmail.com
Password: cs.....................................................................................................................................................2@gmail.com</code></pre>

            <p>
                Here's what happens during authentication:
            </p>

            <ol>
                <li>Application normalizes login email to <code>cs2@gmail.com</code></li>
                <li>Retrieves stored password hash from database</li>
                <li>Uses bcrypt to compare entered password with stored hash</li>
                <li>Bcrypt truncates our 72-byte password input at 72 bytes (which is the full email)</li>
                <li>This matches the hash stored during registration (which was also just the 72-byte email)</li>
                <li>Authentication succeeds!</li>
            </ol>

            <div class="attack-chain">
                <h4>Authentication Flow</h4>
                <div class="attack-step">User enters 72-byte email as password</div>
                <div class="attack-step">Bcrypt truncates at 72 bytes (entire email, no random data)</div>
                <div class="attack-step">Compares with stored hash (also just the 72-byte email)</div>
                <div class="attack-step">Match! User authenticated successfully</div>
            </div>

            <h3>Step 4: Access Granted</h3>

            <p>
                Upon successful authentication, the application creates a session and redirects to the dashboard. We've successfully bypassed the authentication system with predictable credentials!
            </p>

            <div class="info">
                <strong>Attack Success:</strong> We can now access the authenticated area of the application using credentials we controlled from the beginning. The "random" password was completely ineffective due to bcrypt truncation.
            </div>

            <hr class="section-divider">

            <h2>Impact Assessment</h2>

            <p>
                This vulnerability chain has severe security implications for any production system:
            </p>

            <h3>Immediate Threats</h3>

            <ul>
                <li><strong>Complete Authentication Bypass:</strong> Attackers can register and immediately access accounts without needing the temporary password</li>
                <li><strong>No Dependency on Email Delivery:</strong> The attack works regardless of whether email functionality is implemented</li>
                <li><strong>Predictable Credentials:</strong> Anyone who registers using this technique knows their own password</li>
                <li><strong>Session Hijacking Potential:</strong> Once authenticated, attackers have full session access</li>
            </ul>

            <h3>Attack Scalability</h3>

            <div class="danger">
                <strong>Mass Registration Risk:</strong> An attacker could register thousands of accounts using variations of this technique, all with predictable passwords. Rate limiting on the registration endpoint provides limited protection since each registration is "legitimate" from the application's perspective.
            </div>

            <h3>Real-World Scenarios</h3>

            <ol>
                <li><strong>Data Theft:</strong> Attacker creates accounts to access sensitive information or services</li>
                <li><strong>Platform Abuse:</strong> Automated bot accounts for spam, scraping, or manipulation</li>
                <li><strong>Resource Exhaustion:</strong> Creating numerous accounts to exhaust system resources</li>
                <li><strong>Reputation Damage:</strong> Public disclosure of such a vulnerability seriously damages trust</li>
            </ol>

            <hr class="section-divider">

            <h2>Root Cause Analysis</h2>

            <p>
                Let's examine the fundamental design flaws that enabled this vulnerability:
            </p>

            <h3>1. Inconsistent Data Processing</h3>

            <p>
                The most critical error was applying different transformations to the same input at different stages:
            </p>

            <pre><code>// Validation stage
const nEmail = normalizeEmail(req.body.email)  // Transformed
if (nEmail.length > 64) { ... }

// Password generation stage
const initialPassword = req.body.email + ...   // Raw, untransformed</code></pre>

            <div class="danger">
                <strong>Principle Violated:</strong> When applying security controls, always use the same version of data throughout the process. If you validate normalized data, generate cryptographic material from normalized data too.
            </div>

            <h3>2. Misunderstanding Cryptographic Primitives</h3>

            <p>
                The developers didn't account for bcrypt's 72-byte truncation behavior when designing the password generation logic. This is a well-documented characteristic that should influence implementation decisions.
            </p>

            <h3>3. User-Controlled Secret Components</h3>

            <p>
                Including user input (email address) in generated passwords is fundamentally problematic:
            </p>

            <pre><code>// Bad: User controls part of the "random" password
const initialPassword = req.body.email + crypto.randomBytes(16).toString('hex')

// Good: Password is entirely random
const initialPassword = crypto.randomBytes(32).toString('hex')</code></pre>

            <h3>4. Incomplete Feature Implementation</h3>

            <p>
                The commented-out email functionality (<code>// TODO: Send email with initial password</code>) was a red flag that this registration flow wasn't production-ready. The security model depended on users not knowing their temporary password, but without email delivery, this assumption was already broken.
            </p>

            <hr class="section-divider">

            <h2>Remediation</h2>

            <p>
                Here's how to properly fix these vulnerabilities and prevent similar issues in the future.
            </p>

            <h3>Fix #1: Consistent Email Processing</h3>

            <p>
                Always normalize email addresses immediately upon receipt and use the normalized version everywhere:
            </p>

            <pre><code>app.post('/user', limiter, (req, res, next) => {
    if (!req.body) return res.redirect('/login')

    // Normalize once, use everywhere
    const email = normalizeEmail(req.body.email)

    // Validate BOTH normalized and raw lengths
    if (email.length > 64 || req.body.email.length > 72) {
        req.session.error = 'Your email address is too long'
        return res.redirect('/login')
    }

    // Use normalized email for password generation
    const initialPassword = email + crypto.randomBytes(16).toString('hex')
    
    // Rest of implementation...
})</code></pre>

            <h3>Fix #2: Remove User Input from Password Generation</h3>

            <p>
                Generate completely random passwords without any user-controlled components:
            </p>

            <pre><code>// Generate 32 random bytes = 64 hex characters
// Well within bcrypt's 72-byte limit with safety margin
const initialPassword = crypto.randomBytes(32).toString('hex')</code></pre>

            <h3>Fix #3: Validate Before Bcrypt</h3>

            <p>
                Add an explicit check to prevent passwords from exceeding bcrypt's limit:
            </p>

            <pre><code>const initialPassword = crypto.randomBytes(32).toString('hex')

// Verify we're within bcrypt's limits
if (Buffer.byteLength(initialPassword, 'utf8') > 72) {
    throw new Error('Generated password exceeds bcrypt maximum length')
}

bcrypt.hash(initialPassword, 10, function (err, hash) {
    // ... rest of implementation
})</code></pre>

            <h3>Fix #4: Implement Proper Password Delivery</h3>

            <p>
                Complete the email functionality or implement a more secure registration flow:
            </p>

            <pre><code>// Option 1: Send password via email
const transporter = nodemailer.createTransport(config)
await transporter.sendMail({
    to: email,
    subject: 'Your temporary password',
    text: `Your temporary password is: ${initialPassword}`
})

// Option 2: Use password reset flow instead
// Generate a one-time token, email it to user
// Let user set their own password via secure link</code></pre>

            <h3>Fix #5: Add Comprehensive Input Validation</h3>

            <pre><code>const emailValidator = require('email-validator')

// Validate email format
if (!emailValidator.validate(req.body.email)) {
    req.session.error = 'Invalid email format'
    return res.redirect('/login')
}

// Validate both raw and normalized lengths
const rawEmail = req.body.email
const normalizedEmail = normalizeEmail(rawEmail)

if (rawEmail.length > 255 || normalizedEmail.length > 64) {
    req.session.error = 'Email address is too long'
    return res.redirect('/login')
}</code></pre>

            <hr class="section-divider">

            <h2>Lessons Learned</h2>

            <h3>For Developers</h3>

            <ul>
                <li><strong>Understand your crypto primitives:</strong> Know the limitations and behaviors of libraries like bcrypt, including input truncation</li>
                <li><strong>Process data consistently:</strong> Apply the same transformations throughout your code when making security decisions</li>
                <li><strong>Never trust user input in secrets:</strong> Generated passwords should be purely random without user-controlled components</li>
                <li><strong>Validate comprehensively:</strong> Check constraints on data in both raw and processed forms</li>
                <li><strong>Complete features before deployment:</strong> Partially implemented security features (like email delivery) often hide vulnerabilities</li>
            </ul>

            <h3>For Security Reviewers</h3>

            <ul>
                <li><strong>Look for data transformation inconsistencies:</strong> Pay attention to where and how input is processed</li>
                <li><strong>Review crypto implementation details:</strong> Don't assume developers understand cryptographic primitives' edge cases</li>
                <li><strong>Check for user-controlled components:</strong> Secrets should never include user input</li>
                <li><strong>Test boundary conditions:</strong> Exploit edge cases like maximum input lengths</li>
                <li><strong>Verify defense in depth:</strong> Single points of failure in security controls are warning signs</li>
            </ul>

            <hr class="section-divider">

            <h2>Conclusion</h2>

            <p>
                This vulnerability demonstrates a crucial principle in application security: vulnerabilities often emerge from the subtle interactions between multiple components rather than obvious coding errors. Each individual piece—bcrypt hashing, email normalization, random password generation—was implemented using industry-standard libraries and best practices. Yet their combination created a critical authentication bypass.
            </p>

            <p>
                The key takeaway is the importance of understanding not just what your security tools do, but how they behave at their boundaries and how they interact with other components. Bcrypt's 72-byte truncation is well-documented, but it becomes a vulnerability only when combined with user-controlled input in password generation and inconsistent input processing.
            </p>

    <footer>
        <hr style="border: none; border-top: 1px dashed #ccc; margin-bottom: 10px;">
        <nav style="text-align: center; font-size: 1.2rem;">        <nav>
            <a href="index.html">~/</a>
        </nav>
        <div style="font-size: 0.95rem; color: #666; margin-top: 5px;">
            back.
        </div>
    </footer>
</body>
</html>